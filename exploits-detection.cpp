/* ===================================================================== */
/* Zou Quanchen */
/* ===================================================================== */

#include "pin.H"
#include <asm/unistd.h>
#include <fstream>
#include <iostream>
#include <list>

#define LOCKED    1
#define UNLOCKED  !LOCKED

#define DEBUG 
#define DEBUG_HEAP_BASED_UAF
#define DEBUG_HEAP_OVERFLOW
//#define DEBUG_STACK_BASED_UAF
#define DEBUG_STACK_OVERFLOW
//#define DEBUG_FORMAT_STRING

#define NextIT(_x) ((++_x)--)


/* ===================================================================== */
/* Global Variables */
/* ===================================================================== */
static size_t         lastSize;
static size_t         timerJiffies;

static UINT16       _tabAddr[0x10000];
static std::string  _tabStr[0x10000];

#ifdef DEBUG_STACK_OVERFLOW
static UINT64 oldAddrWritten = 0;
static UINT64 counterWrite = 0;
static UINT64 oldRIP = 0;
#endif

struct heapBlock
{
  UINT64  location;
  UINT64  size;
};

struct loopList_s
{
  UINT32 idLoop;
  std::list<UINT64> addrs;
};

static UINT64 stID = 0;

struct stackFrameVar_s
{
  UINT64 addrVar;
  UINT64 sizeVar;
  UINT64 rsp;
};

struct VSA
{
  std::list<struct stackFrameVar_s> stackFrameVar;
};

struct VSA VSAL[64];

struct RoutineInfo
{
	UINT64 RtnAddress;
	UINT64 size;
}

UINT32 lockTaint = LOCKED;

std::list<UINT64>               addressTainted;
std::list<REG>                  regsTainted;
std::list<struct heapBlock>    mallocList;
std::list<struct heapBlock>     freeList;


ADDRINT mainImage_low;
ADDRINT mainImcage_high;

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    cerr << "This tool produces a trace of calls to normal and ifunc memcpy." << endl;
    cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
    return -1;
}

VOID WriteMem(UINT64 insAddr, std::string insDis, UINT32 opCount, REG reg_r, UINT64 memOp)
{
  std::list<struct heapBlock>::iterator i;
  UINT64 addr = memOp;
  PIN_LockClient();
  IMG img = IMG_FindByAddress(addr);
  PIN_UnlockClient();
  SEC sec;
  
  if (opCount != 2){
    return;
  }

  /* Check if the address is in a section */
  for(sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec)){
    if (addr >= SEC_Address(sec) && addr < (SEC_Address(sec) + SEC_Size(sec)))
      return;
  }


  for(i = freeList.begin(); i != freeList.end(); i++){
	  if (addr >= i->location && addr < (i->location + i->size)){
		  std::cout << std::hex << "[Heap-based UAF in " << addr << "]"<< insAddr << ": " << insDis  << std::endl;
		  return;
	  }
  }


  /* Check if the address is mapped */
  for(i = mallocList.begin(); i != mallocList.end(); i++){
    if (addr >= i->location && addr < (i->location + i->size)){
    	//判断写入的数据长度与当前堆块大小
    	//std::cout << std::hex << "[Heap overflow in " << addr << "]"<< insAddr << ": " << insDis << std::endl;
    	//std::cout  << "[write memory in malloc list]########################"<< std::endl;
    	return;
    }
  }addrVar
 
  /* check if the address is in a stack area */
  if (addr > 0x700000000000)
    return;
 
  std::cout << std::hex << "[Heap overflow in " << addr << "]"<< insAddr << ": " << insDis << std::endl;
}

//call instruction
VOID PrologueAnalysis(UINT64 insAddr, UINT64 nextInsAddr, std::string insDis)
{
  UINT64  i = 0;
  list<struct stackFrameVar_s>::iterator it;

  if (nextInsAddr >= 0x4004a0){
    #ifdef DEBUG
      std::cout << "[Function opened] " << std::hex <<insDis << " retrun addr after call:"<< nextInsAddr  << std::endl;
    #endif

    if (VSAL[stID].stackFrameVar.size() == 0){
      stID++;
      return;
    }

    /* premiere passe */
    for(it = VSAL[stID].stackFstd::list<struct heapBlock>     freeList;rameVar.begin(); it != VSAL[stID].stackFrameVar.end(); it++){
      if (i++ != 0){
        it->sizeVar = it->addrVar - (--it)->addrVar;
        it++;
      }
    }

    /* deuxieme passe */
    for(it = VSAL[stID].stackFrameVar.begin(); it != VSAL[stID].stackFrameVar.end(); it++){
      if (it->sizeVar == 0 && it->rsp < it->addrVar){
        it->sizeVar = it->addrVar - it->rsp;
      }
    }

    stID++;
  }
}

//callback when ret instruction exec
VOID EpilogueAnalysis(UINT64 insAddr, UINT64 nextInsAddr, std::string insDis)
{
  if (nextInsAddr >= 0x4004a0){
    #ifdef DEBUG
      std::cout << "[Function closed]" << std::endl;
    #endif
  }
}


#ifdef DEBUG_STACK_OVERFLOW
/*形如MOV RBP， REG_INVALID()指令（如mov dword ptr [rbp-0x4], 0x90909090）的内存写操作指令都会回调，用于收集局部变量的信息，分析栈溢出*/
VOID ValueSetAnalysis(UINT64 insAddr, std::string insDis, ADDRINT rsp, ADDRINT rbp, UINT64 memOp, UINT64 opCode)
{
  UINT64 addrRBP = memOp;
  struct stackFrameVar_s elem;
  list<struct stackFrameVar_s>::iterator i;

  #ifdef DEBUG
    std::cout <<"[write to stack] "<< insAddr << ": " << insDis << " (rsp: " << std::hex << rsp << ") (rbp: " << rbp << ") (dest: " << addrRBP << ") (opCode:"<< opCode<< ") (stack frame ID: " << std::dec << stID << ")" << std::endl;
  #endif

  /* Ajout des variables de la stack frame dans une VSAL */
  /* stID est unique pour chaque stack frame */
  elem.addrVar = addrRBP;
  elem.sizeVar = 0;
  elem.rsp     = rsp;
  /* boucle pour eviter les doublons et eviter d'avoir plusieur */
  /* variables pour une meme initialisation */
  for(i = VSAL[stID].stackFrameVar.begin(); i != VSAL[stID].stackFrameVar.end(); i++){
    if (i->addrVar == addrRBP)
      return;std::list<struct heapBlock>     freeList;
  }

  if (VSAL[stID].stackFrameVar.size() == 0){
    VSAL[stID].stackFrameVar.push_back(elem);
    return;
  }

  for(i = VSAL[stID].stackFrameVar.begin(); i != VSAL[stID].stackFrameVar.end(); i++){
    if (i->addrVar > addrRBP){
      VSAL[stID].stackFrameVar.push_front(elem);
      return;
    }
  }
  VSAL[stID].stackFrameVar.push_back(elem);
}
#endif

VOID timerHandler(UINT64 prevAddr, UINT64 insAddr, UINT64 nextAddr, std::string insDis)
{
  timerJiffies++;


  if (insAddr > 0x700000000000)
    return;
 
  if (_tabAddr[insAddr ^ 0x400000] == 0xffff)
    return;
 
  _tabAddr[insAddr ^ 0x400000] += 1;
  _tabStr[insAddr ^ 0x400000] = insDis;
}

/* Analyzes stack overflow */
#ifdef DEBUG_STACK_OVERFLOW
/*每一条写内存操作指令都会回调**/
VOID WriteMemAnalysis(UINT64 insAddr, std::string insDis, UINT64 memOp)
{
  list<struct stackFrameVar_s>::iterator it;
  list<struct stackFrameVar_s>::iterator itNext;
  UINT64 addr = memOp;
  

//  if (_tabAddr[insAddr ^ 0x400000] < 2)
//    return;

  for(it = VSAL[stID].stackFrameVar.begin(); it != VSAL[stID].stackFrameVar.end(); it++){
    //std::cout << "addr     = " << std::hex << addr << std::endl;
    //std::cout << "addrVar  = " << std::hex << it->addrVar << std::endl;
    //std::cout << "addrSize = " << std::hex << it->sizeVar << std::endl;

    itNext = NextIT(it);
    if (addr >= it->addrVar && addr < itNext->addrVar){
      #ifdef DEBUG
        std::cout << "[Write Mem B] " << std::hex << insAddr << ": " << insDis << std::endl;
      #endif

    if (oldAddrWritten == 0)
      oldAddrWritten = addr;
    

    if (((addr - oldAddrWritten) != 1 && oldAddrWritten != addr) || insAddr != oldRIP){
      counterWrite = 0;
      oldAddrWritten = addr;
    }

    counterWrite++;
    oldRIP = insAddr;

    if (counterWrite > 4){
      std::cout << std::hex << insAddr << ": " << insDis << " -- Stack overflow in " << addr << std::endl;
      counterWrite = 0;
      oldAddrWritten = addr;
    }

    #ifdef DEBUG
      std::cout << "counterWrite: " << std::dec << counterWrite << std::endl;
    #endif
    oldAddrWritten = addr;
    break;
    }
    //  std::cout << "itNext: " << std::hex << itNext->addrVar << std::endl;
  } 
}
#endif

VOID Instruction(INS ins, VOID *v)
{
  PIN_LockClient();
  IMG img = IMG_FindByAddress(INS_Address(ins));
  PIN_UnlockClient();
  
  if (IMG_Valid(img) && IMG_IsMainExecutable(img)){
    if (INS_IsCall(ins)){
      INS_InsertCall(
          ins, IPOINT_BEFORE, (Astd::list<struct heapBlock>     freeList;FUNPTR)PrologueAnalysis,
          IARG_ADDRINT, INS_Address(ins),
          IARG_ADDRINT, INS_NextAddress(ins),
          IARG_PTR, new string(INS_Disassemble(ins)),
          IARG_END);
    }
    else if (INS_IsRet(ins)){
      INS_InsertCall(
          ins, IPOINT_BEFORE, (AFUNPTR)EpilogueAnalysis,
          IARG_ADDRINT, INS_Address(ins),
          IARG_ADDRINT, INS_NextAddress(ins),
          IARG_PTR, new string(INS_Disassemble(ins)),
          IARG_END);
    }
    else if (INS_OperandCount(ins) > 1 && INS_MemoryOperandIsWritten(ins, 0)){
      INS_InsertCall(
          ins, IPOINT_BEFORE, (AFUNPTR)WriteMem,
          IARG_ADDRINT, INS_Address(ins),
          IARG_PTR, new string(INS_Disassemble(ins)),
          IARG_UINT32, INS_OperandCount(ins),
          IARG_UINT32, INS_OperandReg(ins, 1),
          IARG_MEMORYOP_EA, 0,
          IARG_END);
    }


    #ifdef DEBUG_STACK_OVERFLOW
    /* Value Set Analysis */
    if (INS_Opcode(ins) == XED_ICLASS_MOV &&
        INS_RegR(ins, 0) == REG_RBP && 
        INS_RegR(ins, 1) == REG_INVALID() && 
        INS_IsMemoryWrite(ins)){
      INS_InsertCall(
          ins, IPOINT_BEFORE, (AFUNPTR)ValueSetAnalysis,
          IARG_ADDRINT, INS_Address(ins),
          IARG_PTR, new string(INS_Disassemble(ins)),
          IARG_REG_VALUE, REG_RSP,
          IARG_REG_VALUE, REG_RBP,
          IARG_MEMORYOP_EA, 0,
		  IARG_UINT32, INS_Opcode(ins),// opcode
          IARG_END);
    }
    #endif

    #ifdef DEBUG_STACK_OVERFLOW
    /* Analyzes stack overflow */
    if (INS_MemoryOperandIsWritten(ins, 0)){
        INS_InsertCall(
            ins, IPOINT_BEFORE, (AFUNPTR)WriteMemAnalysis,
            IARG_ADDRINT, INS_Address(ins),
            IARG_PTR, new string(INS_Disassemble(ins)),
            IARG_MEMORYOP_EA, 0,
            IARG_END);
      }
    #endif


    /* Timer Handler - And instruction counter */
    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)timerHandler, 
      IARG_ADDRINT, INS_Address(INS_Prev(ins)),
      IARG_ADDRINT, INS_Address(ins),
      IARG_ADDRINT, INS_Address(INS_Next(ins)),
      IARG_PTR, new string(INS_Disassemble(ins)),
      IARG_END);
  }
}


VOID callbackBeforeMalloc(ADDRINT size)
{
  lastSize = size;
}

VOID callbackBeforeFree(ADDRINT addr)
{ 
  list<struct heapBlock>::iterator i;
  struct heapBlock elem;
  
  #ifdef DEBUG
    std::cout << "[INFO] free(" << std::hex << addr << ")" << std::endl;
  #endif
  for(i = mallocList.begin(); i != mallocList.end(); i++){
    if (addr == i->location){
    	  elem.location = addr;
    	  elem.size = i->size;
    	  freeList.push_front(elem);
    	  //std::cout << "free list add!" << std::hex << addr <<"\t" << i->size << std::endl;
    	  mallocList.erase(i);
      break;
    }
  }

}

VOID callbackAfterMalloc(ADDRINT ret)
{
  list<struct heapBlock>::iterator i;
  struct heapBlock elem;

  #ifdef DEBUG
    std::cout << "[INFO] malloc(" << std::dec << lastSize << ") = " << std::hex << ret << std::endl;
  #endif
  if (ret){
    for(i = freeList.begin(); i != freeList.end(); i++){
      if (ret == i->location){
        freeList.erase(i);
        break;
      }
    }
    elem.location = ret;
    elem.size = lastSize;
    mallocList.push_front(elem);
  }
}

/* ===================================================================== */
/* Analysis routines                                                     */
/* ===================================================================== */

VOID MemcpyBefore(CHAR * name, ADDRINT dst, ADDRINT src, ADDRINT size)
{
	std::cout << "[memcpy info &&&&&&&&&&&&&&&&]" << std::endl;
	std::cout << name << "(" << dst << "," << src << "," << size << ")" << endl;
}

VOID Image(IMG img, VOID *v)
{
  RTN memcpyRtn = RTN_FindByName(img, "memcpy");
  RTN mallocRtn = RTN_FindByName(img, "malloc");
  RTN freeRtn = RTN_FindByName(img, "free");

  if (!IMG_IsMainExecutable(img))
      {
	      std::cout << "Ignoring image: " << IMG_Name(img) << endl;
          return;
      }

      std::cout << "Parsing image: " << IMG_Name(img) << endl;
      for( SYM sym = IMG_RegsymHead(img); SYM_Valid(sym); sym = SYM_Next(sym) )
      {
    	  std::cout << "Symbol " << SYM_Name(sym) << " address 0x"
                  << hex << SYM_Address(sym) << endl;

          RTN rtn = RTN_FindByName(img, SYM_Name(sym).c_str());
          if (!RTN_Valid(rtn))
          {
        	  std::cout << "Routine not found, continue..." << endl;
              continue;
          }

          std::cout << "Routine " << RTN_Name(rtn) << " address 0x"
                  << hex << RTN_Address(rtn) << " size 0x"
                  << hex << RTN_Size(rtn) << endl;
      }
//  if (IMG_IsMainExecutable(img)) {
//	printf(
//		"LowAddress: %lx HighAddress: %lx ImageBase: %lx: %s\n",
//		IMG_LowAddress(img),
//		IMG_HighAddress(img),
//		IMG_StartAddress(img),
//		IMG_Name(img).c_str()
//	);
//    mainImage_low  = IMG_LowAddress(img);
//	mainImage_high = IMG_HighAddress(img);
//  }

  if (RTN_Valid(memcpyRtn)){
 	  std::cout << "[find memcpy!]" << std::endl;
 	 RTN_Open(memcpyRtn);
 	 //TraceFile << "Normal memcpy" << endl;

 	 // Instrument memcpy() to print the input argument value and the return value.
 	 RTN_InsertCall(memcpyRtn, IPOINT_BEFORE, (AFUNPTR)MemcpyBefore,
 	                IARG_ADDRINT, "memcpy (normal)",
 	                IARG_FUNCARG_ENTRYPOINT_VALUE, 0,
 	                IARG_FUNCARG_ENTRYPOINT_VALUE, 1,
 	                IARG_FUNCARG_ENTRYPOINT_VALUE, 2,
 	                IARG_END);

 	 RTN_Close(memcpyRtn);
   }/*
   else {
      #ifdef DEBUG
         std::cout << "[can not find memcpy**]" << std::endl;
      #endif
   }*/

  if (RTN_Valid(mallocRtn)){
    RTN_Open(mallocRtn);

    RTN_InsertCall(
        mallocRtn, 
        IPOINT_BEFORE, (AFUNPTR)callbackBeforeMalloc,
        IARG_FUNCARG_ENTRYPOINT_VALUE, 0,
        IARG_END);

    RTN_InsertCall(
        mallocRtn, 
        IPOINT_AFTER, (AFUNPTR)callbackAfterMalloc,
        IARG_FUNCRET_EXITPOINT_VALUE, 
        IARG_END);

    RTN_Close(mallocRtn);
  }

  if (RTN_Valid(freeRtn)){
    RTN_Open(freeRtn);
    RTN_InsertCall(
        freeRtn, 
        IPOINT_BEFORE, (AFUNPTR)callbackBeforeFree,
        IARG_FUNCARG_ENTRYPOINT_VALUE, 0,
        IARG_END);
    RTN_Close(freeRtn);
  }




}

#ifdef DEBUG_STACK_OVERFLOW
VOID Fini(INT32 code, VOID *v)
{
  UINT32 i;
  list<struct stackFrameVar_s>::iterator it;
  
  for (i = 0; i < 32; i++){
    if (VSAL[i].stackFrameVar.size()){
      std::cout << "id stack frame: " << std::dec << i << "\t Num var: " << VSAL[i].stackFrameVar.size() << " ( ";

      for(it = VSAL[i].stackFrameVar.begin(); it != VSAL[i].stackFrameVar.end(); it++){
        std::cout << std::hex << it->addrVar << ":" << std::dec << it->sizeVar << " ";
      }
      std::cout << ")" << std::endl;
    }
  }

  std::cout << "------------------" << std::endl;
  std::cout << "Addr\tNumber\tDisass" << std::endl;
  for (i = 0; i < 0x10000; i++){
    if (_tabAddr[i])
      std::cout << std::hex << (0x400000 + i) << "\t" << std::dec << _tabAddr[i] << "\t" << _tabStr[i] << std::endl;
  }
}
#endif


/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char *argv[])
{
    //PIN_InitSymbols();
	// Initialize pin & symbol manager
    PIN_InitSymbolsAlt(SYMBOL_INFO_MODE(UINT32(IFUNC_SYMBOLS) | UINT32(DEBUG_OR_EXPORT_SYMBOLS)));
    if(PIN_Init(argc, argv)){
        return Usage();
    }
    
    PIN_SetSyntaxIntel();

    // Register Image to be called to instrument functions.
    IMG_AddInstrumentFunction(Image, 0);

    INS_AddInstrumentFunction(Instruction, 0);
    #ifdef DEBUG_STACK_OVERFLOW
      PIN_AddFiniFunction(Fini, 0);
    #endif

    // Never returns
    PIN_StartProgram();
    
    return 0;
}

/* ===================================================================== */
/* eof */
/* ===================================================================== */
